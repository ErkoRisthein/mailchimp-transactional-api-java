/*
 * Mailchimp Transactional API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.59
 * Contact: apihelp@mailchimp.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package io.github.erkoristhein.mailchimp.model;

import java.util.Objects;
import java.util.Arrays;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import io.github.erkoristhein.mailchimp.model.PostMessagesSendTemplateRequestMessage;
import io.github.erkoristhein.mailchimp.model.PostMessagesSendTemplateRequestTemplateContentInner;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.fasterxml.jackson.annotation.JsonTypeName;

/**
 * PostMessagesSendTemplateRequest
 */
@JsonPropertyOrder({
  PostMessagesSendTemplateRequest.JSON_PROPERTY_KEY,
  PostMessagesSendTemplateRequest.JSON_PROPERTY_TEMPLATE_NAME,
  PostMessagesSendTemplateRequest.JSON_PROPERTY_TEMPLATE_CONTENT,
  PostMessagesSendTemplateRequest.JSON_PROPERTY_MESSAGE,
  PostMessagesSendTemplateRequest.JSON_PROPERTY_ASYNC,
  PostMessagesSendTemplateRequest.JSON_PROPERTY_IP_POOL,
  PostMessagesSendTemplateRequest.JSON_PROPERTY_SEND_AT
})
@JsonTypeName("postMessagesSendTemplate_request")
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-04-26T17:07:48.465004+03:00[Europe/Helsinki]", comments = "Generator version: 7.5.0")
public class PostMessagesSendTemplateRequest {
  public static final String JSON_PROPERTY_KEY = "key";
  private String key;

  public static final String JSON_PROPERTY_TEMPLATE_NAME = "template_name";
  private String templateName;

  public static final String JSON_PROPERTY_TEMPLATE_CONTENT = "template_content";
  private List<PostMessagesSendTemplateRequestTemplateContentInner> templateContent = new ArrayList<>();

  public static final String JSON_PROPERTY_MESSAGE = "message";
  private PostMessagesSendTemplateRequestMessage message;

  public static final String JSON_PROPERTY_ASYNC = "async";
  private Boolean async;

  public static final String JSON_PROPERTY_IP_POOL = "ip_pool";
  private String ipPool;

  public static final String JSON_PROPERTY_SEND_AT = "send_at";
  private OffsetDateTime sendAt;

  public PostMessagesSendTemplateRequest() {
  }

  public PostMessagesSendTemplateRequest key(String key) {
    
    this.key = key;
    return this;
  }

   /**
   * a valid api key
   * @return key
  **/
  @jakarta.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_KEY)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public String getKey() {
    return key;
  }


  @JsonProperty(JSON_PROPERTY_KEY)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setKey(String key) {
    this.key = key;
  }


  public PostMessagesSendTemplateRequest templateName(String templateName) {
    
    this.templateName = templateName;
    return this;
  }

   /**
   * the immutable slug of a template that exists in the user&#39;s account. Make sure you don&#39;t use the template name as this one might change.
   * @return templateName
  **/
  @jakarta.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_TEMPLATE_NAME)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public String getTemplateName() {
    return templateName;
  }


  @JsonProperty(JSON_PROPERTY_TEMPLATE_NAME)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setTemplateName(String templateName) {
    this.templateName = templateName;
  }


  public PostMessagesSendTemplateRequest templateContent(List<PostMessagesSendTemplateRequestTemplateContentInner> templateContent) {
    
    this.templateContent = templateContent;
    return this;
  }

  public PostMessagesSendTemplateRequest addTemplateContentItem(PostMessagesSendTemplateRequestTemplateContentInner templateContentItem) {
    if (this.templateContent == null) {
      this.templateContent = new ArrayList<>();
    }
    this.templateContent.add(templateContentItem);
    return this;
  }

   /**
   * an array of template content to send. Each item in the array should be a struct with two keys - name: the name of the content block to set the content for, and content: the actual content to put into the block
   * @return templateContent
  **/
  @jakarta.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_TEMPLATE_CONTENT)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public List<PostMessagesSendTemplateRequestTemplateContentInner> getTemplateContent() {
    return templateContent;
  }


  @JsonProperty(JSON_PROPERTY_TEMPLATE_CONTENT)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setTemplateContent(List<PostMessagesSendTemplateRequestTemplateContentInner> templateContent) {
    this.templateContent = templateContent;
  }


  public PostMessagesSendTemplateRequest message(PostMessagesSendTemplateRequestMessage message) {
    
    this.message = message;
    return this;
  }

   /**
   * Get message
   * @return message
  **/
  @jakarta.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_MESSAGE)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public PostMessagesSendTemplateRequestMessage getMessage() {
    return message;
  }


  @JsonProperty(JSON_PROPERTY_MESSAGE)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setMessage(PostMessagesSendTemplateRequestMessage message) {
    this.message = message;
  }


  public PostMessagesSendTemplateRequest async(Boolean async) {
    
    this.async = async;
    return this;
  }

   /**
   * enable a background sending mode that is optimized for bulk sending. In async mode, messages/send will immediately return a status of \&quot;queued\&quot; for every recipient. To handle rejections when sending in async mode, set up a webhook for the &#39;reject&#39; event. Defaults to false for messages with no more than 10 recipients; messages with more than 10 recipients are always sent asynchronously, regardless of the value of async.
   * @return async
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_ASYNC)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Boolean getAsync() {
    return async;
  }


  @JsonProperty(JSON_PROPERTY_ASYNC)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setAsync(Boolean async) {
    this.async = async;
  }


  public PostMessagesSendTemplateRequest ipPool(String ipPool) {
    
    this.ipPool = ipPool;
    return this;
  }

   /**
   * the name of the dedicated ip pool that should be used to send the message. If you do not have any dedicated IPs, this parameter has no effect. If you specify a pool that does not exist, your default pool will be used instead.
   * @return ipPool
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_IP_POOL)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getIpPool() {
    return ipPool;
  }


  @JsonProperty(JSON_PROPERTY_IP_POOL)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setIpPool(String ipPool) {
    this.ipPool = ipPool;
  }


  public PostMessagesSendTemplateRequest sendAt(OffsetDateTime sendAt) {
    
    this.sendAt = sendAt;
    return this;
  }

   /**
   * when this message should be sent as a UTC timestamp in YYYY-MM-DD HH:MM:SS format. If you specify a time in the past, the message will be sent immediately; for future dates, you&#39;re limited to one year from the date of scheduling.
   * @return sendAt
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_SEND_AT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public OffsetDateTime getSendAt() {
    return sendAt;
  }


  @JsonProperty(JSON_PROPERTY_SEND_AT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setSendAt(OffsetDateTime sendAt) {
    this.sendAt = sendAt;
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    PostMessagesSendTemplateRequest postMessagesSendTemplateRequest = (PostMessagesSendTemplateRequest) o;
    return Objects.equals(this.key, postMessagesSendTemplateRequest.key) &&
        Objects.equals(this.templateName, postMessagesSendTemplateRequest.templateName) &&
        Objects.equals(this.templateContent, postMessagesSendTemplateRequest.templateContent) &&
        Objects.equals(this.message, postMessagesSendTemplateRequest.message) &&
        Objects.equals(this.async, postMessagesSendTemplateRequest.async) &&
        Objects.equals(this.ipPool, postMessagesSendTemplateRequest.ipPool) &&
        Objects.equals(this.sendAt, postMessagesSendTemplateRequest.sendAt);
  }

  @Override
  public int hashCode() {
    return Objects.hash(key, templateName, templateContent, message, async, ipPool, sendAt);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class PostMessagesSendTemplateRequest {\n");
    sb.append("    key: ").append(toIndentedString(key)).append("\n");
    sb.append("    templateName: ").append(toIndentedString(templateName)).append("\n");
    sb.append("    templateContent: ").append(toIndentedString(templateContent)).append("\n");
    sb.append("    message: ").append(toIndentedString(message)).append("\n");
    sb.append("    async: ").append(toIndentedString(async)).append("\n");
    sb.append("    ipPool: ").append(toIndentedString(ipPool)).append("\n");
    sb.append("    sendAt: ").append(toIndentedString(sendAt)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

