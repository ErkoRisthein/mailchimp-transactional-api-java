/*
 * Mailchimp Transactional API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.55
 * Contact: apihelp@mailchimp.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package io.github.erkoristhein.mailchimp.model;

import java.util.Objects;
import java.util.Arrays;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.fasterxml.jackson.annotation.JsonTypeName;

/**
 * PostMessagesSendRawRequest
 */
@JsonPropertyOrder({
  PostMessagesSendRawRequest.JSON_PROPERTY_KEY,
  PostMessagesSendRawRequest.JSON_PROPERTY_RAW_MESSAGE,
  PostMessagesSendRawRequest.JSON_PROPERTY_FROM_EMAIL,
  PostMessagesSendRawRequest.JSON_PROPERTY_FROM_NAME,
  PostMessagesSendRawRequest.JSON_PROPERTY_TO,
  PostMessagesSendRawRequest.JSON_PROPERTY_ASYNC,
  PostMessagesSendRawRequest.JSON_PROPERTY_IP_POOL,
  PostMessagesSendRawRequest.JSON_PROPERTY_SEND_AT,
  PostMessagesSendRawRequest.JSON_PROPERTY_RETURN_PATH_DOMAIN
})
@JsonTypeName("postMessagesSendRaw_request")
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-01-19T14:58:48.420021+02:00[Europe/Tallinn]")
public class PostMessagesSendRawRequest {
  public static final String JSON_PROPERTY_KEY = "key";
  private String key;

  public static final String JSON_PROPERTY_RAW_MESSAGE = "raw_message";
  private String rawMessage;

  public static final String JSON_PROPERTY_FROM_EMAIL = "from_email";
  private String fromEmail;

  public static final String JSON_PROPERTY_FROM_NAME = "from_name";
  private String fromName;

  public static final String JSON_PROPERTY_TO = "to";
  private List<String> to;

  public static final String JSON_PROPERTY_ASYNC = "async";
  private Boolean async;

  public static final String JSON_PROPERTY_IP_POOL = "ip_pool";
  private String ipPool;

  public static final String JSON_PROPERTY_SEND_AT = "send_at";
  private OffsetDateTime sendAt;

  public static final String JSON_PROPERTY_RETURN_PATH_DOMAIN = "return_path_domain";
  private String returnPathDomain;

  public PostMessagesSendRawRequest() {
  }

  public PostMessagesSendRawRequest key(String key) {
    
    this.key = key;
    return this;
  }

   /**
   * a valid api key
   * @return key
  **/
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_KEY)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public String getKey() {
    return key;
  }


  @JsonProperty(JSON_PROPERTY_KEY)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setKey(String key) {
    this.key = key;
  }


  public PostMessagesSendRawRequest rawMessage(String rawMessage) {
    
    this.rawMessage = rawMessage;
    return this;
  }

   /**
   * the full MIME document of an email message
   * @return rawMessage
  **/
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_RAW_MESSAGE)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public String getRawMessage() {
    return rawMessage;
  }


  @JsonProperty(JSON_PROPERTY_RAW_MESSAGE)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setRawMessage(String rawMessage) {
    this.rawMessage = rawMessage;
  }


  public PostMessagesSendRawRequest fromEmail(String fromEmail) {
    
    this.fromEmail = fromEmail;
    return this;
  }

   /**
   * optionally define the sender address - otherwise we&#39;ll use the address found in the provided headers
   * @return fromEmail
  **/
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_FROM_EMAIL)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getFromEmail() {
    return fromEmail;
  }


  @JsonProperty(JSON_PROPERTY_FROM_EMAIL)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setFromEmail(String fromEmail) {
    this.fromEmail = fromEmail;
  }


  public PostMessagesSendRawRequest fromName(String fromName) {
    
    this.fromName = fromName;
    return this;
  }

   /**
   * optionally define the sender alias
   * @return fromName
  **/
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_FROM_NAME)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getFromName() {
    return fromName;
  }


  @JsonProperty(JSON_PROPERTY_FROM_NAME)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setFromName(String fromName) {
    this.fromName = fromName;
  }


  public PostMessagesSendRawRequest to(List<String> to) {
    
    this.to = to;
    return this;
  }

  public PostMessagesSendRawRequest addToItem(String toItem) {
    if (this.to == null) {
      this.to = new ArrayList<>();
    }
    this.to.add(toItem);
    return this;
  }

   /**
   * optionally define the recipient to receive the message - otherwise we&#39;ll use the To, Cc, and Bcc headers provided in the document
   * @return to
  **/
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_TO)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public List<String> getTo() {
    return to;
  }


  @JsonProperty(JSON_PROPERTY_TO)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setTo(List<String> to) {
    this.to = to;
  }


  public PostMessagesSendRawRequest async(Boolean async) {
    
    this.async = async;
    return this;
  }

   /**
   * enable a background sending mode that is optimized for bulk sending. In async mode, messages/sendRaw will immediately return a status of \&quot;queued\&quot; for every recipient. To handle rejections when sending in async mode, set up a webhook for the &#39;reject&#39; event. Defaults to false for messages with no more than 10 recipients; messages with more than 10 recipients are always sent asynchronously, regardless of the value of async.
   * @return async
  **/
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_ASYNC)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Boolean getAsync() {
    return async;
  }


  @JsonProperty(JSON_PROPERTY_ASYNC)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setAsync(Boolean async) {
    this.async = async;
  }


  public PostMessagesSendRawRequest ipPool(String ipPool) {
    
    this.ipPool = ipPool;
    return this;
  }

   /**
   * the name of the dedicated ip pool that should be used to send the message. If you do not have any dedicated IPs, this parameter has no effect. If you specify a pool that does not exist, your default pool will be used instead.
   * @return ipPool
  **/
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_IP_POOL)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getIpPool() {
    return ipPool;
  }


  @JsonProperty(JSON_PROPERTY_IP_POOL)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setIpPool(String ipPool) {
    this.ipPool = ipPool;
  }


  public PostMessagesSendRawRequest sendAt(OffsetDateTime sendAt) {
    
    this.sendAt = sendAt;
    return this;
  }

   /**
   * when this message should be sent as a UTC timestamp in YYYY-MM-DD HH:MM:SS format. If you specify a time in the past, the message will be sent immediately; for future dates, you&#39;re limited to one year from the date of scheduling.
   * @return sendAt
  **/
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_SEND_AT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public OffsetDateTime getSendAt() {
    return sendAt;
  }


  @JsonProperty(JSON_PROPERTY_SEND_AT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setSendAt(OffsetDateTime sendAt) {
    this.sendAt = sendAt;
  }


  public PostMessagesSendRawRequest returnPathDomain(String returnPathDomain) {
    
    this.returnPathDomain = returnPathDomain;
    return this;
  }

   /**
   * a custom domain to use for the messages&#39;s return-path
   * @return returnPathDomain
  **/
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_RETURN_PATH_DOMAIN)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getReturnPathDomain() {
    return returnPathDomain;
  }


  @JsonProperty(JSON_PROPERTY_RETURN_PATH_DOMAIN)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setReturnPathDomain(String returnPathDomain) {
    this.returnPathDomain = returnPathDomain;
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    PostMessagesSendRawRequest postMessagesSendRawRequest = (PostMessagesSendRawRequest) o;
    return Objects.equals(this.key, postMessagesSendRawRequest.key) &&
        Objects.equals(this.rawMessage, postMessagesSendRawRequest.rawMessage) &&
        Objects.equals(this.fromEmail, postMessagesSendRawRequest.fromEmail) &&
        Objects.equals(this.fromName, postMessagesSendRawRequest.fromName) &&
        Objects.equals(this.to, postMessagesSendRawRequest.to) &&
        Objects.equals(this.async, postMessagesSendRawRequest.async) &&
        Objects.equals(this.ipPool, postMessagesSendRawRequest.ipPool) &&
        Objects.equals(this.sendAt, postMessagesSendRawRequest.sendAt) &&
        Objects.equals(this.returnPathDomain, postMessagesSendRawRequest.returnPathDomain);
  }

  @Override
  public int hashCode() {
    return Objects.hash(key, rawMessage, fromEmail, fromName, to, async, ipPool, sendAt, returnPathDomain);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class PostMessagesSendRawRequest {\n");
    sb.append("    key: ").append(toIndentedString(key)).append("\n");
    sb.append("    rawMessage: ").append(toIndentedString(rawMessage)).append("\n");
    sb.append("    fromEmail: ").append(toIndentedString(fromEmail)).append("\n");
    sb.append("    fromName: ").append(toIndentedString(fromName)).append("\n");
    sb.append("    to: ").append(toIndentedString(to)).append("\n");
    sb.append("    async: ").append(toIndentedString(async)).append("\n");
    sb.append("    ipPool: ").append(toIndentedString(ipPool)).append("\n");
    sb.append("    sendAt: ").append(toIndentedString(sendAt)).append("\n");
    sb.append("    returnPathDomain: ").append(toIndentedString(returnPathDomain)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

